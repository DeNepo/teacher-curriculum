# Notes

- But teaching is much more complicated. It is widely thought that it is not the job of the teacher to "transfer" knowledge to the students, but instead get the students to do the explaining. - Niels gregersen

- Most effective science teachers also know what students get wrong https://computinged.wordpress.com/2013/05/13/the-critical-part-of-pck-what-students-get-wrong/ maybe the teachers should through the homework be able to figure out what students are mostly struggling with! Coule be easily made into an exercise. First identify what this class struggles with, give the teacher 6 homeworks to look through. Now come up with a plan/worked example/live coding to help the students understand this problem

- Would it be nice to let the students explain where they are weakest, maybe even mentors writing it down

- For debugging, I’m reminded of Beth Simon et al’s recent Peer Instruction work where she was deliberately constructing examples where students were likely to show a shallow or incomplete model of programming, e.g. they would have problems with loops that start at 1, or go backwards, or have less than vs less than or equal to end conditions. As I understand it, Simon et al said there was a fine art in example construction, to make sure it drew out common student misconceptions so that they could be discussed and corrected - https://computinged.wordpress.com/2013/05/13/the-critical-part-of-pck-what-students-get-wrong/

- "The solution seems to be to get the students to make a prediction before the demo." 
What happens when i run this function. What happens if i say type of to this thing. https://academiccomputing.wordpress.com/2012/07/09/science-education-research/ 

- Coming back to helping students identify what their misconceptions are. Creating examples and questions that visualize the students misconceptions

- https://www.youtube.com/watch?v=eVtCO84MDj8 puncturing misconceptions. How can we translate that to coding

- https://www.youtube.com/watch?v=GEmuEWjHr5c - Teacher should guide the social process of learning.  inspire, challenge and excite. Not so much static teaching, more examples, exercises and misconception busting

- Really good comment in this article: https://academiccomputing.wordpress.com/2012/05/11/predicting-live-coding/

- Slowing down when there are mistakes: https://www.youtube.com/watch?v=ChLu2KfIAk4
- Live coding: https://www.youtube.com/watch?v=buFRgtzfmiw

- The mentor should know different problem solving strategies
  - formalization
  - Decomposing a problem into sub-problems
  - abstraction
  - top-down design, bottom-up design, gradual refinement; Generalization, analogy

- The mentor should be able to asses the class from the homework

- Develop homework with varying degrees of scafolding

- Know different informatics teaching approachessuch as
  - live coding
  - peer instruction
  - pair programming
  - worked examples

- develop and execute lesson-plan

- Self evaluation of curriculum/teaching
https://medium.com/luceresearchlab/what-should-cs-teachers-study-2c58a60ed12f, 



From this: https://computinged.wordpress.com/2015/11/04/what-does-a-cs-methods-class-look-like/ <- pretty much the course here

A mentor should be able to
- Be able to describe use and when one should use different CS teaching approaches like live coding, peer instruction, pair programming, worked examples, and kinesthetic learning activities.
- Be able to describe and diagnose common student misconceptions, e.g., with assignments, with while vs. if, and so on.
- Be able to describe approaches to teaching computer science, including constructionist, objects-first, functions-first, media computation.
- Write a lesson plan to teach a CS topic for a specific grade level, including assessments.

Students should be **programming self-sufficiency**

"Learners make little progress when they’re watching your fingers dance over the keyboard, writing code and executing commands at what seems like impossible speed. They’ll quickly slip into a passive mode, watching things happen without truly understanding.

Unless they get hopelessly stuck, your student should drive the keyboard as much as humanly possible. Yes, this may mean painstakingly spelling aloud commands for them to type into the Terminal and that’s OK! They’ll still learn more than if you just do it for them." https://www.codementor.io/@npostolovski/how-to-teach-programming-pvgpdtoed


Figure Out The Learner’s Style

I’ve observed that most people have one of three learning styles when it comes to programming.

    Analogists. These learners love analogies that relate programming concepts to real-world concepts they’re already familiar with. When I was first learning programming, it was helpful to think of a variable as being like a box with a name written on it. Similarly, it was helpful for me to think of methods/functions as recipes. For some learners a well-chosen analogy will help a concept to click almost immediately. Other learners will find talk of ‘boxes’ and ‘recipes’ incredibly confusing! Those learners fall into one of the two other styles.
    How to identify analogists: they’ll come up with their own analogies to explain things.
    Deep Divers. Some learners have an insatiable need to peek beneath the layers of abstraction and truly understand how things work. When introduced to the concept of variables, their first question will often be: how and where is the value of a variable stored? Hand-waving explanations simply won’t cut it for these learners. You’ll find that they regularly test your own computer science knowledge. If you don’t know the answer to one of their questions, take the time to research it. This will make you a better programmer.
    How to identify Deep Divers: they’ll ask lots of challenging questions.
    3. Experimenters. Some learners want you to stop talking and let them try it out for themselves! They’ll learn about variables by testing things out on the command line, assigning and re-assigning variables, giving them weird names, and testing the limits of the system until they break. For these learners, an error message is a rewarding sign that they’ve learned one of the boundaries of the system. These students flourish when you give them the tools to experiment and get out of the way.
    How to identify experimenters: they start experimenting with a new concept before you’ve even finished explaining it to them.

Let’s say your student encounters an error message that they don’t know how to fix. They look to you for guidance. Instead of giving them the answer, instruct them to Google the error message. Help them navigate the results and identify useful sources, such as official documentation, technical blog posts, and StackOverflow. Do this more and more often as your student grows more comfortable with programming. Eventually, they should be getting unstuck using their own research almost all the time. This is an essential element of programming self-sufficiency.

Good questions to ask
Is there anything we’ve covered that you feel you don’t understand as well as you need?
Is there anything we’ve covered where you don’t see why it is important or useful?
Do you feel like what we’re working on now is helping you progress toward your goals?
Is there anything we haven’t covered that you’d like to learn about?
How is the pacing for you? Too fast? Too slow? Just right?

https://www.codementor.io/@npostolovski/how-to-teach-programming-pvgpdtoed

https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1006023



The pearson problem was pretty cool. With the code already written, but the students have to put it in right order. Fix problems without worrying about syntax. 





